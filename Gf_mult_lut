-- File: gf_mult_lut.vhd
-- Description: GF multiplier using log/antilog lookup tables

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.gf_pkg.all;

entity gf_mult_lut is
    generic (
        GF_M      : integer := 8;
        PRIM_POLY : integer := 285
    );
    port (
        clk     : in  std_logic;
        rst_n   : in  std_logic;
        a       : in  std_logic_vector(GF_M-1 downto 0);
        b       : in  std_logic_vector(GF_M-1 downto 0);
        valid   : in  std_logic;
        product : out std_logic_vector(GF_M-1 downto 0);
        ready   : out std_logic
    );
end entity gf_mult_lut;

architecture rtl of gf_mult_lut is
    
    constant FIELD_SIZE : integer := 2**GF_M;
    constant Q : integer := FIELD_SIZE - 1;
    constant ANTILOG_TABLE : gf_table_t := gen_antilog_table(GF_M, PRIM_POLY);
    constant LOG_TABLE : gf_table_t := gen_log_table(ANTILOG_TABLE, FIELD_SIZE);
    
    attribute rom_style : string;
    attribute rom_style of ANTILOG_TABLE : constant is "M20K";
    attribute rom_style of LOG_TABLE : constant is "M20K";
    
    signal a_reg, b_reg : std_logic_vector(GF_M-1 downto 0);
    signal valid_reg : std_logic;
    
begin
    
    process(clk, rst_n)
        variable a_int, b_int : integer range 0 to FIELD_SIZE-1;
        variable log_a, log_b, log_sum : integer range 0 to Q;
        variable product_int : integer range 0 to FIELD_SIZE-1;
    begin
        if rst_n = '0' then
            product <= (others => '0');
            ready <= '0';
            a_reg <= (others => '0');
            b_reg <= (others => '0');
            valid_reg <= '0';
        elsif rising_edge(clk) then
            a_reg <= a;
            b_reg <= b;
            valid_reg <= valid;
            ready <= valid_reg;
            
            if valid_reg = '1' then
                a_int := to_integer(unsigned(a_reg));
                b_int := to_integer(unsigned(b_reg));
                
                if a_int = 0 or b_int = 0 then
                    product <= (others => '0');
                else
                    log_a := LOG_TABLE(a_int);
                    log_b := LOG_TABLE(b_int);
                    log_sum := (log_a + log_b) mod Q;
                    product_int := ANTILOG_TABLE(log_sum);
                    product <= std_logic_vector(to_unsigned(product_int, GF_M));
                end if;
            end if;
        end if;
    end process;
    
end architecture rtl;
