-- Extended RS Error Corrector: compatible with n = field size
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity error_corrector_ext is
    generic (
        GF_M : integer := 8;
        N    : integer := 256;  -- n = field size for extended RS
        T    : integer := 16
    );
    port (
        clk             : in  std_logic;
        rst_n           : in  std_logic;
        start           : in  std_logic;
        received_data   : in  std_logic_vector(N*GF_M-1 downto 0);
        error_locations : in  std_logic_vector(T*8-1 downto 0);
        error_values    : in  std_logic_vector(T*GF_M-1 downto 0);
        num_errors      : in  integer range 0 to T;
        corrected_data  : out std_logic_vector(N*GF_M-1 downto 0);
        valid           : out std_logic
    );
end entity error_corrector_ext;

architecture rtl of error_corrector_ext is
    type symbol_array_t is array (0 to N-1) of std_logic_vector(GF_M-1 downto 0);
    signal data_buffer : symbol_array_t := (others => (others => '0'));
    type state_t is (IDLE, LOAD, CORRECT, DONE_STATE);
    signal state : state_t := IDLE;
    signal error_index : integer range 0 to T := 0;
begin
    correction_proc : process(clk, rst_n)
        variable location  : integer range 0 to N-1;
        variable error_val : std_logic_vector(GF_M-1 downto 0);
        variable i         : integer range 0 to N-1;
    begin
        if rst_n = '0' then
            state <= IDLE;
            valid <= '0';
            error_index <= 0;
            data_buffer <= (others => (others => '0'));
            corrected_data <= (others => '0');
        elsif rising_edge(clk) then
            case state is
                when IDLE =>
                    valid <= '0';
                    if start = '1' then
                        -- move to LOAD state to transfer received_data into buffer
                        error_index <= 0;
                        state <= LOAD;
                    end if;

                when LOAD =>
                    -- Load received_data into data_buffer (done in one clock here)
                    for i in 0 to N-1 loop
                        data_buffer(i) <= received_data((i+1)*GF_M-1 downto i*GF_M);
                    end loop;
                    -- prepare to correct errors
                    error_index <= 0;
                    state <= CORRECT;

                when CORRECT =>
                    if error_index < num_errors then
                        location := to_integer(unsigned(error_locations((error_index+1)*8-1 downto error_index*8)));
                        error_val := error_values((error_index+1)*GF_M-1 downto error_index*GF_M);
                        if location < N then
                            -- apply error value (XOR) to the buffered symbol
                            data_buffer(location) <= data_buffer(location) xor error_val;
                        end if;
                        error_index <= error_index + 1;
                    else
                        state <= DONE_STATE;
                    end if;

                when DONE_STATE =>
                    -- pack buffer back into corrected_data
                    for i in 0 to N-1 loop
                        corrected_data((i+1)*GF_M-1 downto i*GF_M) <= data_buffer(i);
                    end loop;
                    valid <= '1';
                    state <= IDLE;

                when others =>
                    -- cover any unexpected state values (synthesis-friendly fallback)
                    state <= IDLE;
            end case;
        end if;
    end process;
end architecture rtl;
