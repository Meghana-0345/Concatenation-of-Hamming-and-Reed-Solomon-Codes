library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity hamming_decoder_parallel is
  generic (
    N : positive := 15;
    K : positive := 11;
    NUM_SYMBOLS : positive := 15
  );
  port (
    clk : in std_logic;
    rst : in std_logic;
    
    data_in : in std_logic_vector(NUM_SYMBOLS * N - 1 downto 0);
    data_in_valid : in std_logic;
    data_in_ready : buffer std_logic;
    
    data_out : out std_logic_vector(NUM_SYMBOLS * K - 1 downto 0);
    data_out_valid : out std_logic;
    data_out_ready : in std_logic;
    
    error_flags : out std_logic_vector(NUM_SYMBOLS - 1 downto 0)
  );
end entity hamming_decoder_parallel;

architecture rtl of hamming_decoder_parallel is

  constant H_MATRIX_ROW0 : std_logic_vector(14 downto 0) := "111010100000000";
  constant H_MATRIX_ROW1 : std_logic_vector(14 downto 0) := "110101010000000";
  constant H_MATRIX_ROW2 : std_logic_vector(14 downto 0) := "101100110000000";
  constant H_MATRIX_ROW3 : std_logic_vector(14 downto 0) := "011011110000000";

begin

  process (clk)
    variable received_codeword : std_logic_vector(N - 1 downto 0);
    variable syndrome : std_logic_vector(3 downto 0);
    variable error_pos : integer;
    variable corrected_codeword : std_logic_vector(N - 1 downto 0);
    variable decoded_info : std_logic_vector(K - 1 downto 0);
    variable j : integer;
  begin
    if rising_edge(clk) then
      if rst = '1' then
        data_out <= (others => '0');
        data_out_valid <= '0';
        error_flags <= (others => '0');
        data_in_ready <= '0';
      elsif data_in_valid = '1' and data_in_ready = '1' then
        
        for i in 0 to NUM_SYMBOLS - 1 loop
          received_codeword := data_in((i+1) * N - 1 downto i * N);
          
          syndrome(0) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW0(j) = '1' then
              syndrome(0) := syndrome(0) xor received_codeword(j);
            end if;
          end loop;
          
          syndrome(1) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW1(j) = '1' then
              syndrome(1) := syndrome(1) xor received_codeword(j);
            end if;
          end loop;
          
          syndrome(2) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW2(j) = '1' then
              syndrome(2) := syndrome(2) xor received_codeword(j);
            end if;
          end loop;
          
          syndrome(3) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW3(j) = '1' then
              syndrome(3) := syndrome(3) xor received_codeword(j);
            end if;
          end loop;
          
          error_pos := to_integer(unsigned(syndrome));
          
          corrected_codeword := received_codeword;
          if error_pos /= 0 then
            corrected_codeword(error_pos - 1) := not corrected_codeword(error_pos - 1);
            error_flags(i) <= '1';
          else
            error_flags(i) <= '0';
          end if;
          
          decoded_info(0) := corrected_codeword(2);
          decoded_info(1) := corrected_codeword(4);
          decoded_info(2) := corrected_codeword(5);
          decoded_info(3) := corrected_codeword(6);
          decoded_info(4) := corrected_codeword(8);
          decoded_info(5) := corrected_codeword(9);
          decoded_info(6) := corrected_codeword(10);
          decoded_info(7) := corrected_codeword(11);
          decoded_info(8) := corrected_codeword(12);
          decoded_info(9) := corrected_codeword(13);
          decoded_info(10) := corrected_codeword(14);
          
          data_out((i+1) * K - 1 downto i * K) <= decoded_info;
        end loop;
        
        data_out_valid <= '1';
        data_in_ready <= '0';
      else
        data_out_valid <= '0';
        data_in_ready <= '1';
      end if;
    end if;
  end process;

end architecture rtl;
