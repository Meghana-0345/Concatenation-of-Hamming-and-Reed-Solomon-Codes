library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity hamming_encoder_symbol_level is
  generic (
    N : positive := 15;
    K : positive := 11
  );
  port (
    clk : in std_logic;
    rst_n : in std_logic;
    
    -- Input: one information symbol per clock
    data_in : in std_logic_vector(K - 1 downto 0);
    data_in_valid : in std_logic;
    data_ready : out std_logic;
    
    -- Output: one Hamming-encoded codeword per clock
    codeword_out : out std_logic_vector(N - 1 downto 0);
    codeword_valid : out std_logic;
    done : out std_logic
  );
end entity hamming_encoder_symbol_level;

architecture rtl of hamming_encoder_symbol_level is

  constant H_MATRIX_ROW0 : std_logic_vector(14 downto 0) := "111010100000000";
  constant H_MATRIX_ROW1 : std_logic_vector(14 downto 0) := "110101010000000";
  constant H_MATRIX_ROW2 : std_logic_vector(14 downto 0) := "101100110000000";
  constant H_MATRIX_ROW3 : std_logic_vector(14 downto 0) := "011011110000000";
  
  type state_t is (IDLE, ENCODE, DONE_STATE);
  signal state : state_t;
  signal symbol_count : integer range 0 to N;

begin

  process (clk, rst_n)
    variable output_codeword : std_logic_vector(N - 1 downto 0);
    variable parity : std_logic_vector(3 downto 0);
    variable j : integer;
  begin
    if rst_n = '0' then
      state <= IDLE;
      codeword_out <= (others => '0');
      codeword_valid <= '0';
      data_ready <= '0';
      done <= '0';
      symbol_count <= 0;
    elsif rising_edge(clk) then
      case state is
        when IDLE =>
          done <= '0';
          codeword_valid <= '0';
          data_ready <= '0';
          symbol_count <= 0;
          
          if data_in_valid = '1' then
            state <= ENCODE;
            data_ready <= '1';
          end if;

        when ENCODE =>
          -- Place information bits at non-power-of-2 positions
          output_codeword(0) := '0';
          output_codeword(1) := '0';
          output_codeword(2) := data_in(0);
          output_codeword(3) := '0';
          output_codeword(4) := data_in(1);
          output_codeword(5) := data_in(2);
          output_codeword(6) := data_in(3);
          output_codeword(7) := '0';
          output_codeword(8) := data_in(4);
          output_codeword(9) := data_in(5);
          output_codeword(10) := data_in(6);
          output_codeword(11) := data_in(7);
          output_codeword(12) := data_in(8);
          output_codeword(13) := data_in(9);
          output_codeword(14) := data_in(10);
          
          -- Calculate parity bits
          parity(0) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW0(j) = '1' then
              parity(0) := parity(0) xor output_codeword(j);
            end if;
          end loop;
          
          parity(1) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW1(j) = '1' then
              parity(1) := parity(1) xor output_codeword(j);
            end if;
          end loop;
          
          parity(2) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW2(j) = '1' then
              parity(2) := parity(2) xor output_codeword(j);
            end if;
          end loop;
          
          parity(3) := '0';
          for j in 0 to N - 1 loop
            if H_MATRIX_ROW3(j) = '1' then
              parity(3) := parity(3) xor output_codeword(j);
            end if;
          end loop;
          
          -- Insert parity bits
          output_codeword(0) := parity(0);
          output_codeword(1) := parity(1);
          output_codeword(3) := parity(2);
          output_codeword(7) := parity(3);
          
          codeword_out <= output_codeword;
          codeword_valid <= '1';
          symbol_count <= symbol_count + 1;
          
          if symbol_count = N - 1 then
            state <= DONE_STATE;
            data_ready <= '0';
          else
            if data_in_valid = '0' then
              state <= DONE_STATE;
            end if;
          end if;

        when DONE_STATE =>
          codeword_valid <= '0';
          done <= '1';
          state <= IDLE;
      end case;
    end if;
  end process;

end architecture rtl;
