-- File: rs_decoder.vhd
-- Description: Reed-Solomon decoder top-level
-- MIT License - Copyright (c) 2025

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.gf_pkg.all;

entity rs_decoder is
    generic (
        GF_M      : integer := 4;
        N         : integer := 16;
        K         : integer := 11;
        T         : integer := 2;
        PRIM_POLY : integer := 19;
        SHORTENED : integer := 0
    );
    port (
        clk               : in  std_logic;
        rst_n             : in  std_logic;
        start             : in  std_logic;
        codeword_in       : in  std_logic_vector(GF_M-1 downto 0);
        data_valid        : in  std_logic;
        erasure_location  : in  std_logic_vector(7 downto 0);
        erasure_valid     : in  std_logic;
        decoding_done     : out std_logic;
        corrected_data_out: out std_logic_vector(GF_M-1 downto 0);
        output_valid      : out std_logic;
        error_count       : out integer range 0 to T;
        failure_flag      : out std_logic;
        busy              : out std_logic
    );
end entity rs_decoder;

architecture rtl of rs_decoder is
    
    constant NPARITY : integer := 2 * T;
    
    type codeword_buffer_t is array (0 to N-1) of std_logic_vector(GF_M-1 downto 0);
    signal codeword_buffer, corrected_buffer : codeword_buffer_t;
    
    signal syndrome_out : std_logic_vector(NPARITY*GF_M-1 downto 0);
    signal syndrome_valid, syndrome_busy : std_logic;
    signal lambda_out, omega_out : std_logic_vector((T+1)*GF_M-1 downto 0);
    signal bm_error_count : integer range 0 to T;
    signal bm_valid, bm_busy : std_logic;
    signal error_locations : std_logic_vector(T*8-1 downto 0);
    signal error_found : std_logic_vector(T-1 downto 0);
    signal num_errors_found : integer range 0 to T;
    signal chien_valid, chien_busy : std_logic;
    signal error_values : std_logic_vector(T*GF_M-1 downto 0);
    signal forney_valid, forney_busy : std_logic;
    signal received_codeword, corrected_codeword : std_logic_vector(N*GF_M-1 downto 0);
    signal correction_valid : std_logic;
    
    type state_t is (IDLE, RECEIVE, SYNDROME, BM_WAIT, CHIEN_WAIT, FORNEY_WAIT, CORRECT, OUTPUT, ERROR_STATE);
    signal state : state_t;
    signal symbol_count, output_count : integer range 0 to N;
    signal start_syndrome, start_bm, start_chien, start_forney, start_correct : std_logic;
    
    component rs_syndrome_calc is
        generic (GF_M, N, T, PRIM_POLY : integer);
        port (clk, rst_n, start : in std_logic; symbol_in : in std_logic_vector(GF_M-1 downto 0);
              symbol_valid : in std_logic; syndromes_out : out std_logic_vector((2*T)*GF_M-1 downto 0);
              syndromes_valid, busy : out std_logic);
    end component;
    
    component berlekamp_massey is
        generic (GF_M, T, PRIM_POLY : integer);
        port (clk, rst_n, start : in std_logic; syndromes_in : in std_logic_vector((2*T)*GF_M-1 downto 0);
              erasure_count : in integer range 0 to T; lambda_out, omega_out : out std_logic_vector((T+1)*GF_M-1 downto 0);
              error_count_out : out integer range 0 to T; valid, busy : out std_logic);
    end component;
    
    component chien_search is
        generic (GF_M, N, T, PRIM_POLY : integer);
        port (clk, rst_n, start : in std_logic; lambda_in : in std_logic_vector((T+1)*GF_M-1 downto 0);
              error_count : in integer range 0 to T; error_locations : out std_logic_vector(T*8-1 downto 0);
              error_found : out std_logic_vector(T-1 downto 0); num_errors_found : out integer range 0 to T;
              valid, busy : out std_logic);
    end component;
    
    component forney_algorithm is
        generic (GF_M, T, PRIM_POLY : integer);
        port (clk, rst_n, start : in std_logic; lambda_in, omega_in : in std_logic_vector((T+1)*GF_M-1 downto 0);
              error_locations : in std_logic_vector(T*8-1 downto 0); num_errors : in integer range 0 to T;
              error_values : out std_logic_vector(T*GF_M-1 downto 0); valid, busy : out std_logic);
    end component;
    
    component error_corrector is
        generic (GF_M, N, T : integer);
        port (clk, rst_n, start : in std_logic; received_data : in std_logic_vector(N*GF_M-1 downto 0);
              error_locations : in std_logic_vector(T*8-1 downto 0); error_values : in std_logic_vector(T*GF_M-1 downto 0);
              num_errors : in integer range 0 to T; corrected_data : out std_logic_vector(N*GF_M-1 downto 0); valid : out std_logic);
    end component;
    
begin
    
    syndrome_inst : rs_syndrome_calc generic map (GF_M, N, T, PRIM_POLY)
        port map (clk, rst_n, start_syndrome, codeword_in, data_valid, syndrome_out, syndrome_valid, syndrome_busy);
    
    bm_inst : berlekamp_massey generic map (GF_M, T, PRIM_POLY)
        port map (clk, rst_n, start_bm, syndrome_out, 0, lambda_out, omega_out, bm_error_count, bm_valid, bm_busy);
    
    chien_inst : chien_search generic map (GF_M, N, T, PRIM_POLY)
        port map (clk, rst_n, start_chien, lambda_out, bm_error_count, error_locations, error_found, num_errors_found, chien_valid, chien_busy);
    
    forney_inst : forney_algorithm generic map (GF_M, T, PRIM_POLY)
        port map (clk, rst_n, start_forney, lambda_out, omega_out, error_locations, num_errors_found, error_values, forney_valid, forney_busy);
    
    corrector_inst : error_corrector generic map (GF_M, N, T)
        port map (clk, rst_n, start_correct, received_codeword, error_locations, error_values, num_errors_found, corrected_codeword, correction_valid);
    
    decoder_fsm : process(clk, rst_n)
        variable syndromes_zero : boolean;
        variable i : integer range 0 to N-1;
    begin
        if rst_n = '0' then
            state <= IDLE;
            busy <= '0';
            decoding_done <= '0';
            output_valid <= '0';
            failure_flag <= '0';
            symbol_count <= 0;
            output_count <= 0;
            start_syndrome <= '0';
            start_bm <= '0';
            start_chien <= '0';
            start_forney <= '0';
            start_correct <= '0';
            codeword_buffer <= (others => (others => '0'));
            corrected_buffer <= (others => (others => '0'));
            received_codeword <= (others => '0');
        elsif rising_edge(clk) then
            start_syndrome <= '0';
            start_bm <= '0';
            start_chien <= '0';
            start_forney <= '0';
            start_correct <= '0';
            
            case state is
                when IDLE =>
                    busy <= '0';
                    decoding_done <= '0';
                    output_valid <= '0';
                    failure_flag <= '0';
                    symbol_count <= 0;
                    if start = '1' then
                        state <= RECEIVE;
                        busy <= '1';
                        start_syndrome <= '1';
                    end if;
                when RECEIVE =>
                    if data_valid = '1' then
                        codeword_buffer(symbol_count) <= codeword_in;
                        symbol_count <= symbol_count + 1;
                        if symbol_count = N - 1 then
                            state <= SYNDROME;
                        end if;
                    end if;
                when SYNDROME =>
                    if syndrome_valid = '1' then
                        syndromes_zero := true;
                        for i in 0 to NPARITY-1 loop
                            if unsigned(syndrome_out((i+1)*GF_M-1 downto i*GF_M)) /= 0 then
                                syndromes_zero := false;
                            end if;
                        end loop;
                        if syndromes_zero then
                            corrected_buffer <= codeword_buffer;
                            state <= OUTPUT;
                            output_count <= 0;
                        else
                            start_bm <= '1';
                            state <= BM_WAIT;
                        end if;
                    end if;
                when BM_WAIT =>
                    if bm_valid = '1' then
                        if bm_error_count > T then
                            state <= ERROR_STATE;
                        else
                            start_chien <= '1';
                            state <= CHIEN_WAIT;
                        end if;
                    end if;
                when CHIEN_WAIT =>
                    if chien_valid = '1' then
                        if num_errors_found /= bm_error_count then
                            state <= ERROR_STATE;
                        else
                            start_forney <= '1';
                            state <= FORNEY_WAIT;
                        end if;
                    end if;
                when FORNEY_WAIT =>
                    if forney_valid = '1' then
                        for i in 0 to N-1 loop
                            received_codeword((i+1)*GF_M-1 downto i*GF_M) <= codeword_buffer(i);
                        end loop;
                        start_correct <= '1';
                        state <= CORRECT;
                    end if;
                when CORRECT =>
                    if correction_valid = '1' then
                        for i in 0 to N-1 loop
                            corrected_buffer(i) <= corrected_codeword((i+1)*GF_M-1 downto i*GF_M);
                        end loop;
                        state <= OUTPUT;
                        output_count <= 0;
                        error_count <= num_errors_found;
                    end if;
                when OUTPUT =>
                    if output_count < K then
                        corrected_data_out <= corrected_buffer(output_count);
                        output_valid <= '1';
                        output_count <= output_count + 1;
                    else
                        output_valid <= '0';
                        decoding_done <= '1';
                        busy <= '0';
                        state <= IDLE;
                    end if;
                when ERROR_STATE =>
                    failure_flag <= '1';
                    busy <= '0';
                    decoding_done <= '1';
                    error_count <= 0;
                    state <= IDLE;
            end case;
        end if;
    end process;
    
end architecture rtl;
