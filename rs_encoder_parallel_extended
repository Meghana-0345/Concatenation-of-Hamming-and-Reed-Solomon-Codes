library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity rs_encoder_parallel_extended is
  generic (
    GF_M      : integer := 4;
    RS_N      : integer := 16;
    RS_K      : integer := 7;
    RS_T      : integer := 4;
    PRIM_POLY : integer := 19;
    NUM_BLOCKS : positive := 11
  );
  port (
    clk : in std_logic;
    rst_n : in std_logic;
    
    data_in : in std_logic_vector(NUM_BLOCKS * GF_M - 1 downto 0);
    data_in_valid : in std_logic;
    data_ready : out std_logic;
    
    data_out : out std_logic_vector(RS_N * GF_M - 1 downto 0);
    data_out_valid : out std_logic;
    data_out_ready : in std_logic
  );
end entity rs_encoder_parallel_extended;

architecture rtl of rs_encoder_parallel_extended is

  signal data_ready_internal : std_logic;

begin

  process (clk, rst_n)
    variable rs_codeword : std_logic_vector(RS_N * GF_M - 1 downto 0);
  begin
    if rst_n = '0' then
      data_out <= (others => '0');
      data_out_valid <= '0';
      data_ready_internal <= '0';
    elsif rising_edge(clk) then
      if data_in_valid = '1' and data_ready_internal = '1' then
        
        -- Place information symbols
        for i in 0 to NUM_BLOCKS - 1 loop
          rs_codeword((i + 1) * GF_M - 1 downto i * GF_M) := data_in((i + 1) * GF_M - 1 downto i * GF_M);
        end loop;
        
        -- Parity symbols (simplified)
        for i in NUM_BLOCKS to RS_N - 1 loop
          rs_codeword((i + 1) * GF_M - 1 downto i * GF_M) := (others => '0');
        end loop;
        
        -- Output codeword
        for i in 0 to RS_N - 1 loop
          data_out((i + 1) * GF_M - 1 downto i * GF_M) <= rs_codeword((i + 1) * GF_M - 1 downto i * GF_M);
        end loop;
        
        data_out_valid <= '1';
        data_ready_internal <= '0';
      else
        data_out_valid <= '0';
        data_ready_internal <= '1';
      end if;
    end if;
  end process;

  -- Output assignment
  data_ready <= data_ready_internal;

end architecture rtl;
